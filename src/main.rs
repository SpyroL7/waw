mod input_handler;
mod consts;
mod config_use;

use input_handler::{process_flags, enable_options};
use consts::*;
use config_use::*;

use git2::{Repository, Error};
use std::collections::HashMap;
use std::env;
use regex::Regex;
use chrono::Local;



fn main() -> Result<(), Error> {
    let untagged = "untagged".to_string();

    let mut options: Vec<bool> = vec![false; 10];
    let mut args: Vec<String> = env::args().skip(1).collect();  // skips the first redundant argument

    let mut path = match get_path() {  // try to get path from config
        Ok(path) => path,
        Err(e) => panic!("Error finding path: {}", e),
    };

    let mut arg_vector = vec![vec![]; 5];
    let mut first = true;
    let mut flags = String::new();
    let mut time_seconds: i64 = 0;

    if args.len() > 0 && args[0].starts_with("-c") {  // config editing mode
        let flags = args.remove(0);
        match process_flags(String::from(&flags[2..]), &mut args) {
            Ok(_) => {},
            Err(e) => panic!("Error editing config file: {}", e),
        };
    } else {  // display data mode
        let current_time = Local::now().timestamp();
        // TODO put this is a 'display stats' function
        let mut new_args = vec![];
        for arg in &args {  // find flags, make list of arguments, process and repeat
            if !arg.starts_with("-") {
                new_args.push(arg.to_string());
            } else {
                if !first {  // gets the flag(s) before the list of arguments when a new flag is encountered
                    enable_options(flags, new_args, &mut options, &mut path, &mut time_seconds, &mut arg_vector);
                    new_args = vec![];
                } else {
                    first = false;
                }
                flags = String::from(&arg[1..]);
            }
        }
        if !first {  // use final flag when we run out of arguments
            enable_options(flags, new_args, &mut options, &mut path, &mut time_seconds, &mut arg_vector);
        }

        let repo = match Repository::open(path) {
            Ok(repo) => repo,
            Err(e) => panic!("Couldn't find repo: {}", e),
        };

        let mut commit_counter: HashMap<String, (usize, usize, usize, Vec<usize>)> = HashMap::new();
        let mut rw = match repo.revwalk() {
            Ok(rw) => rw,
            Err(e) => {
                println!("Error creating revwalk: {}", e);
                return Err(e.into());
             }
        };

        let config_map = match get_map() {  // reads config file and puts data in map
            Ok(config_map) => config_map,
            Err(e) => panic!("Couldn't parse config file: {}", e),
        };

        let pattern = r"\[([^,\]]+)(?:, ([^,\]]+))*\]";
        let regex = Regex::new(pattern).unwrap();

        let _ = rw.push_head()?;
        for commit in rw.filter_map(|x| x.ok()) {  // iterate over commit graph with revwalk
            // println!("{:?}", get_branch_name(commit));
            let commit_obj = repo.find_commit(commit)?;
            let parent_commit = match commit_obj.parent(0) {
                Ok(parent) => parent,
                Err(_)  => commit_obj.clone(),
            };
            let stats = repo.diff_tree_to_tree(Some(&parent_commit.tree()?), Some(&commit_obj.tree()?), None)?.stats()?;
            let author_name = match commit_obj.committer().name() {
                Some(name) => name.to_string(),
                None => "ERROR".to_string(),
            };

            let (data, msg) = match commit_obj.message() {  // split at colon to get 'data' (type of commit and contributors)
                Some(commit_msg) => match commit_msg.split_once(":") {
                    Some((data, msg)) => (data, msg),
                    _ => ("", commit_msg),
                },
                None => ("", ""),  // probably shouldn't end up here even if there is no colon
            };
            
            let mut found = false;
            let filtered = !options[3] || arg_vector[FILTERS].iter().any(|f| data.contains(f));
            let case_insensitive = !options[4] || arg_vector[CI_SEARCH].iter().any(|s| data.to_lowercase().contains(&s.to_lowercase()) || msg.to_lowercase().contains(&s.to_lowercase()));
            let searched = !options[7] || arg_vector[SEARCH].iter().any(|s| data.contains(s) || msg.contains(s));
            let timed = !options[9] || current_time - commit_obj.time().seconds() <= time_seconds;
            // println!("dif(days): {}", (current_time - commit_obj.time().seconds()) / (60*60*24));

            if options[5] {  // using autogenerated config with commit message data
                if let Some(captures) = regex.captures(data) {
                    for cap in captures.iter().skip(1) {
                        if let Some(author) = cap {
                            let author_s = author.as_str().to_string();
                            let excluded = !options[6] || !arg_vector[EXCLUDE].contains(&author_s);
                            if filtered && case_insensitive && excluded && searched && timed {
                                let counter = commit_counter.entry(author_s).or_insert((0, 0, 0, vec![]));
                                counter.0 += 1;
                                counter.1 += stats.insertions();
                                counter.2 += stats.deletions();
                                counter.3.push(stats.insertions() + stats.deletions());
                            }
                        }
                    }  // TODO: make filter case insensitive
                } else {  // no contributors listed in the expected format
                    // choose how to deal with this - maybe ignore or have an unknown
                    if !options[6] || !arg_vector[EXCLUDE].contains(&untagged) {
                        let counter = commit_counter.entry(untagged.clone()).or_insert((0, 0, 0, vec![]));
                        counter.0 += 1;
                        counter.1 += stats.insertions();
                        counter.2 += stats.deletions();
                        counter.3.push(stats.insertions() + stats.deletions());
                    }
                }
            } else {
                if !options[2] {  // only do this if we are not ignorning the config
                    for (alias, names) in &config_map {
                        let alias_s = alias.to_string();
                        let excluded = !options[6] || !arg_vector[EXCLUDE].contains(&alias_s);
                        if names.contains(&author_name) || author_name == *alias {
                            if filtered && case_insensitive && excluded && searched && timed {
                                let counter = commit_counter.entry(alias_s).or_insert((0, 0, 0, vec![]));
                                counter.0 += 1;
                                counter.1 += stats.insertions();
                                counter.2 += stats.deletions();
                                counter.3.push(stats.insertions() + stats.deletions());
                            }
                            found = true;
                        }
                    };
                }
                if !found && !options[0] {  // author_name is not an alias or in the config (or we ignored config)
                    let excluded = !options[6] || !arg_vector[EXCLUDE].contains(&author_name);
                    if filtered && case_insensitive && excluded && searched && timed {
                        let counter = commit_counter.entry(author_name).or_insert((0, 0, 0, vec![]));
                        counter.0 += 1;
                        counter.1 += stats.insertions();
                        counter.2 += stats.deletions();
                        counter.3.push(stats.insertions() + stats.deletions());
                    }
                }
            }
        }

        // TODO: prettier printing!
        // println!("{:#?}", commit_counter);
        // TODO median commit length: average is heavily skewed by adding test files and such
        println!("Commits by each user (using/not using config with/without filters, exclusions, searches etc.): \n");
        for (name, (commits, ins, dels, mut lines)) in commit_counter {
            lines.sort();
            let median = lines[lines.len()/2];
            println!("{}:  {}  {}  {}  {}, {}", name, commits, ins, dels, (ins+dels)/commits, median);
        }
    }

    Ok(())
}
